Trick 1:    

    # -----------------------------
    # Trick 1: Warmup Learning Rate
    def adjust_lr(epoch):

        if args.t == 0:
            if epoch <= 39:
                lr = args.lr
            elif 40 <= epoch <= 69:
                lr = args.lr * 0.1
            else:
                lr = args.lr * 0.1 * 0.1
        else:
            if epoch <= 10:
                lr = (args.lr / 10) * (epoch / 10)
            elif 11 <= epoch <= 40:
                lr = args.lr
            elif 41 <= epoch <= 70:
                lr = args.lr / 10
            else:
                lr = args.lr / 100

        
        for g in optimizer.param_groups:
            g['lr'] = lr * g.get('lr_mult', 1)
    
    # -----------------------------


Trick 2:

# -----------------------------
# Trick 2: Random Erasing Augmentation
def decision(probability):
    return random.random() < probability

class RandomErasingAugmentation(object):
    def __init__(self, height, width, interpolation = Image.BILINEAR):
        self.height = height
        self.width = width
        self.interpolation = interpolation

    def __call__(self, img):

        if decision(0.5):
            return img

        while True:
            area = img.size[0] * img.size[1]
            target_area = random.uniform(0.02, 0.4) * area
            aspect_ratio = random.uniform(0.3, 3.33)

            # calculating height and width of the rectagle region to erase
            H_e = int(round(math.sqrt(target_area * aspect_ratio)))
            W_e = int(round(math.sqrt(target_area / aspect_ratio)))

            # selecting random point
            x_e = random.randint(0, img.size[0] - W_e)
            y_e = random.randint(0, img.size[1] - H_e)

            # checking if the rectangle region is inside the image size
            if x_e + W_e <= img.size[0] and y_e + H_e <= img.size[1]:

                # calculating the mean 
                stat = ImageStat.Stat(img)
                mean = [int(elem) for elem in stat.mean]

                # adding the mean
                img = np.asarray(img, dtype = "float32")
                img[y_e : y_e + H_e, x_e : x_e + W_e] = mean

                img = Image.fromarray(img.astype('uint8'), 'RGB')

                return img.resize((self.width, self.height), self.interpolation)
# -----------------------------

Trick 3:


